// AUTOGENERATED with quazal-tools
#![allow(
    clippy::enum_variant_names,
    clippy::module_name_repetitions,
    clippy::too_many_lines,
    clippy::upper_case_acronyms,
    clippy::wildcard_imports
)]
use std::convert::TryFrom;

use num_enum::TryFromPrimitive;
use quazal::prudp::ClientRegistry;
use quazal::rmc::basic::FromStream;
use quazal::rmc::basic::ToStream;
use quazal::rmc::ClientProtocol;
use quazal::rmc::Error;
use quazal::rmc::Protocol;
use quazal::rmc::Request;
use quazal::ClientInfo;
use quazal::Context;
use slog::Logger;

#[allow(unused)]
use super::types::*;
pub const SIMPLE_AUTHENTICATION_PROTOCOL_ID: u16 = 16u16;
#[derive(Debug, TryFromPrimitive)]
#[repr(u32)]
pub enum SimpleAuthenticationProtocolMethod {
    Authenticate = 1u32,
    LoginWithToken = 2u32,
    LoginWithTokenEx = 3u32,
    Login = 4u32,
    LoginWithSubAccount = 5u32,
    Register = 6u32,
    RegisterEx = 7u32,
    LoginWithTokenCafe = 8u32,
    LoginWithTokenCafeEx = 9u32,
}
#[derive(Debug, ToStream, FromStream)]
pub struct AuthenticateRequest {
    pub str_user_name: String,
}
#[derive(Debug, ToStream, FromStream)]
pub struct AuthenticateResponse {
    pub return_value: quazal::rmc::types::QResult,
    pub pid_principal: u32,
    pub p_connection_data: RVConnectionData,
    pub str_return_msg: String,
}
#[derive(Debug, ToStream, FromStream)]
pub struct LoginWithTokenRequest {
    pub str_token: String,
}
#[derive(Debug, ToStream, FromStream)]
pub struct LoginWithTokenResponse {
    pub return_value: quazal::rmc::types::QResult,
    pub pid_principal: u32,
    pub p_connection_data: RVConnectionData,
    pub str_return_msg: String,
}
#[derive(Debug, ToStream, FromStream)]
pub struct LoginWithTokenExRequest {
    pub str_token: String,
    pub o_any_data: quazal::rmc::types::Any<quazal::rmc::types::Data, String>,
}
#[derive(Debug, ToStream, FromStream)]
pub struct LoginWithTokenExResponse {
    pub return_value: quazal::rmc::types::QResult,
    pub pid_principal: u32,
    pub p_connection_data: RVConnectionData,
    pub str_return_msg: String,
}
#[derive(Debug, ToStream, FromStream)]
pub struct LoginRequest {
    pub str_username: String,
    pub str_password: String,
}
#[derive(Debug, ToStream, FromStream)]
pub struct LoginResponse {
    pub return_value: quazal::rmc::types::QResult,
    pub pid_principal: u32,
    pub p_connection_data: RVConnectionData,
    pub str_return_msg: String,
}
#[derive(Debug, ToStream, FromStream)]
pub struct LoginWithSubAccountRequest {
    pub login_data: quazal::rmc::types::Any<quazal::rmc::types::Data, String>,
}
#[derive(Debug, ToStream, FromStream)]
pub struct LoginWithSubAccountResponse {
    pub return_value: quazal::rmc::types::QResult,
    pub pid_principal: u32,
    pub p_connection_data: RVConnectionData,
    pub str_return_msg: String,
}
#[derive(Debug, ToStream, FromStream)]
pub struct RegisterRequest {
    pub vec_my_urls: Vec<quazal::rmc::types::StationURL>,
}
#[derive(Debug, ToStream, FromStream)]
pub struct RegisterResponse {
    pub return_value: quazal::rmc::types::QResult,
    pub pid_connection_id: u32,
    pub url_public: quazal::rmc::types::StationURL,
}
#[derive(Debug, ToStream, FromStream)]
pub struct RegisterExRequest {
    pub vec_my_urls: Vec<quazal::rmc::types::StationURL>,
    pub h_custom_data: quazal::rmc::types::Any<quazal::rmc::types::Data, String>,
}
#[derive(Debug, ToStream, FromStream)]
pub struct RegisterExResponse {
    pub return_value: quazal::rmc::types::QResult,
    pub pid_connection_id: u32,
    pub url_public: quazal::rmc::types::StationURL,
}
#[derive(Debug, ToStream, FromStream)]
pub struct LoginWithTokenCafeRequest {
    pub str_nintendo_token: String,
}
#[derive(Debug, ToStream, FromStream)]
pub struct LoginWithTokenCafeResponse {
    pub return_value: quazal::rmc::types::QResult,
    pub pid_principal: u32,
    pub p_connection_data: RVConnectionData,
    pub str_return_msg: String,
}
#[derive(Debug, ToStream, FromStream)]
pub struct LoginWithTokenCafeExRequest {
    pub str_nintendo_token: String,
    pub o_any_data: quazal::rmc::types::Any<quazal::rmc::types::Data, String>,
}
#[derive(Debug, ToStream, FromStream)]
pub struct LoginWithTokenCafeExResponse {
    pub return_value: quazal::rmc::types::QResult,
    pub pid_principal: u32,
    pub p_connection_data: RVConnectionData,
    pub str_return_msg: String,
}
pub struct SimpleAuthenticationProtocolServer<T: SimpleAuthenticationProtocolServerTrait<CI>, CI>(
    T,
    ::std::marker::PhantomData<CI>,
);
impl<T: SimpleAuthenticationProtocolServerTrait<CI>, CI> SimpleAuthenticationProtocolServer<T, CI> {
    pub fn new(implementation: T) -> Self {
        Self(implementation, ::std::marker::PhantomData)
    }
}
impl<T: SimpleAuthenticationProtocolServerTrait<CI>, CI> Protocol<CI>
    for SimpleAuthenticationProtocolServer<T, CI>
{
    fn id(&self) -> u16 {
        SIMPLE_AUTHENTICATION_PROTOCOL_ID
    }
    fn name(&self) -> String {
        "SimpleAuthenticationProtocol".to_string()
    }
    fn num_methods(&self) -> u32 {
        9u32
    }
    fn handle(
        &self,
        logger: &Logger,
        ctx: &Context,
        ci: &mut ClientInfo<CI>,
        request: &Request,
        client_registry: &ClientRegistry<CI>,
        socket: &std::net::UdpSocket,
    ) -> Result<Vec<u8>, Error> {
        let method = SimpleAuthenticationProtocolMethod::try_from(request.method_id).ok();
        match method {
            None => Err(Error::UnknownMethod),
            Some(SimpleAuthenticationProtocolMethod::Authenticate) => {
                let req = AuthenticateRequest::from_bytes(&request.parameters)?;
                debug!(logger, "Request: {:?}", req);
                let resp = self
                    .0
                    .authenticate(logger, ctx, ci, req, client_registry, socket);
                debug!(logger, "Response: {:?}", resp);
                Ok(resp?.to_bytes())
            }
            Some(SimpleAuthenticationProtocolMethod::LoginWithToken) => {
                let req = LoginWithTokenRequest::from_bytes(&request.parameters)?;
                debug!(logger, "Request: {:?}", req);
                let resp = self
                    .0
                    .login_with_token(logger, ctx, ci, req, client_registry, socket);
                debug!(logger, "Response: {:?}", resp);
                Ok(resp?.to_bytes())
            }
            Some(SimpleAuthenticationProtocolMethod::LoginWithTokenEx) => {
                let req = LoginWithTokenExRequest::from_bytes(&request.parameters)?;
                debug!(logger, "Request: {:?}", req);
                let resp =
                    self.0
                        .login_with_token_ex(logger, ctx, ci, req, client_registry, socket);
                debug!(logger, "Response: {:?}", resp);
                Ok(resp?.to_bytes())
            }
            Some(SimpleAuthenticationProtocolMethod::Login) => {
                let req = LoginRequest::from_bytes(&request.parameters)?;
                debug!(logger, "Request: {:?}", req);
                let resp = self.0.login(logger, ctx, ci, req, client_registry, socket);
                debug!(logger, "Response: {:?}", resp);
                Ok(resp?.to_bytes())
            }
            Some(SimpleAuthenticationProtocolMethod::LoginWithSubAccount) => {
                let req = LoginWithSubAccountRequest::from_bytes(&request.parameters)?;
                debug!(logger, "Request: {:?}", req);
                let resp =
                    self.0
                        .login_with_sub_account(logger, ctx, ci, req, client_registry, socket);
                debug!(logger, "Response: {:?}", resp);
                Ok(resp?.to_bytes())
            }
            Some(SimpleAuthenticationProtocolMethod::Register) => {
                let req = RegisterRequest::from_bytes(&request.parameters)?;
                debug!(logger, "Request: {:?}", req);
                let resp = self
                    .0
                    .register(logger, ctx, ci, req, client_registry, socket);
                debug!(logger, "Response: {:?}", resp);
                Ok(resp?.to_bytes())
            }
            Some(SimpleAuthenticationProtocolMethod::RegisterEx) => {
                let req = RegisterExRequest::from_bytes(&request.parameters)?;
                debug!(logger, "Request: {:?}", req);
                let resp = self
                    .0
                    .register_ex(logger, ctx, ci, req, client_registry, socket);
                debug!(logger, "Response: {:?}", resp);
                Ok(resp?.to_bytes())
            }
            Some(SimpleAuthenticationProtocolMethod::LoginWithTokenCafe) => {
                let req = LoginWithTokenCafeRequest::from_bytes(&request.parameters)?;
                debug!(logger, "Request: {:?}", req);
                let resp =
                    self.0
                        .login_with_token_cafe(logger, ctx, ci, req, client_registry, socket);
                debug!(logger, "Response: {:?}", resp);
                Ok(resp?.to_bytes())
            }
            Some(SimpleAuthenticationProtocolMethod::LoginWithTokenCafeEx) => {
                let req = LoginWithTokenCafeExRequest::from_bytes(&request.parameters)?;
                debug!(logger, "Request: {:?}", req);
                let resp =
                    self.0
                        .login_with_token_cafe_ex(logger, ctx, ci, req, client_registry, socket);
                debug!(logger, "Response: {:?}", resp);
                Ok(resp?.to_bytes())
            }
        }
    }
    fn method_name(&self, method_id: u32) -> Option<String> {
        SimpleAuthenticationProtocolMethod::try_from(method_id)
            .ok()
            .map(|e| format!("{:?}", e))
    }
}
#[allow(unused_variables)]
pub trait SimpleAuthenticationProtocolServerTrait<CI> {
    fn authenticate(
        &self,
        logger: &Logger,
        ctx: &Context,
        ci: &mut ClientInfo<CI>,
        request: AuthenticateRequest,
        client_registry: &ClientRegistry<CI>,
        _socket: &std::net::UdpSocket,
    ) -> Result<AuthenticateResponse, Error> {
        warn!(
            logger,
            "Method {}.{} not implemented",
            "SimpleAuthenticationProtocol",
            stringify!(authenticate)
        );
        Err(quazal::rmc::Error::UnimplementedMethod)
    }
    fn login_with_token(
        &self,
        logger: &Logger,
        ctx: &Context,
        ci: &mut ClientInfo<CI>,
        request: LoginWithTokenRequest,
        client_registry: &ClientRegistry<CI>,
        _socket: &std::net::UdpSocket,
    ) -> Result<LoginWithTokenResponse, Error> {
        warn!(
            logger,
            "Method {}.{} not implemented",
            "SimpleAuthenticationProtocol",
            stringify!(login_with_token)
        );
        Err(quazal::rmc::Error::UnimplementedMethod)
    }
    fn login_with_token_ex(
        &self,
        logger: &Logger,
        ctx: &Context,
        ci: &mut ClientInfo<CI>,
        request: LoginWithTokenExRequest,
        client_registry: &ClientRegistry<CI>,
        _socket: &std::net::UdpSocket,
    ) -> Result<LoginWithTokenExResponse, Error> {
        warn!(
            logger,
            "Method {}.{} not implemented",
            "SimpleAuthenticationProtocol",
            stringify!(login_with_token_ex)
        );
        Err(quazal::rmc::Error::UnimplementedMethod)
    }
    fn login(
        &self,
        logger: &Logger,
        ctx: &Context,
        ci: &mut ClientInfo<CI>,
        request: LoginRequest,
        client_registry: &ClientRegistry<CI>,
        _socket: &std::net::UdpSocket,
    ) -> Result<LoginResponse, Error> {
        warn!(
            logger,
            "Method {}.{} not implemented",
            "SimpleAuthenticationProtocol",
            stringify!(login)
        );
        Err(quazal::rmc::Error::UnimplementedMethod)
    }
    fn login_with_sub_account(
        &self,
        logger: &Logger,
        ctx: &Context,
        ci: &mut ClientInfo<CI>,
        request: LoginWithSubAccountRequest,
        client_registry: &ClientRegistry<CI>,
        _socket: &std::net::UdpSocket,
    ) -> Result<LoginWithSubAccountResponse, Error> {
        warn!(
            logger,
            "Method {}.{} not implemented",
            "SimpleAuthenticationProtocol",
            stringify!(login_with_sub_account)
        );
        Err(quazal::rmc::Error::UnimplementedMethod)
    }
    fn register(
        &self,
        logger: &Logger,
        ctx: &Context,
        ci: &mut ClientInfo<CI>,
        request: RegisterRequest,
        client_registry: &ClientRegistry<CI>,
        _socket: &std::net::UdpSocket,
    ) -> Result<RegisterResponse, Error> {
        warn!(
            logger,
            "Method {}.{} not implemented",
            "SimpleAuthenticationProtocol",
            stringify!(register)
        );
        Err(quazal::rmc::Error::UnimplementedMethod)
    }
    fn register_ex(
        &self,
        logger: &Logger,
        ctx: &Context,
        ci: &mut ClientInfo<CI>,
        request: RegisterExRequest,
        client_registry: &ClientRegistry<CI>,
        _socket: &std::net::UdpSocket,
    ) -> Result<RegisterExResponse, Error> {
        warn!(
            logger,
            "Method {}.{} not implemented",
            "SimpleAuthenticationProtocol",
            stringify!(register_ex)
        );
        Err(quazal::rmc::Error::UnimplementedMethod)
    }
    fn login_with_token_cafe(
        &self,
        logger: &Logger,
        ctx: &Context,
        ci: &mut ClientInfo<CI>,
        request: LoginWithTokenCafeRequest,
        client_registry: &ClientRegistry<CI>,
        _socket: &std::net::UdpSocket,
    ) -> Result<LoginWithTokenCafeResponse, Error> {
        warn!(
            logger,
            "Method {}.{} not implemented",
            "SimpleAuthenticationProtocol",
            stringify!(login_with_token_cafe)
        );
        Err(quazal::rmc::Error::UnimplementedMethod)
    }
    fn login_with_token_cafe_ex(
        &self,
        logger: &Logger,
        ctx: &Context,
        ci: &mut ClientInfo<CI>,
        request: LoginWithTokenCafeExRequest,
        client_registry: &ClientRegistry<CI>,
        _socket: &std::net::UdpSocket,
    ) -> Result<LoginWithTokenCafeExResponse, Error> {
        warn!(
            logger,
            "Method {}.{} not implemented",
            "SimpleAuthenticationProtocol",
            stringify!(login_with_token_cafe_ex)
        );
        Err(quazal::rmc::Error::UnimplementedMethod)
    }
}
pub struct SimpleAuthenticationProtocolClient<CI>(::std::marker::PhantomData<CI>);
impl<CI> SimpleAuthenticationProtocolClient<CI> {
    pub fn new() -> Self {
        Self(::std::marker::PhantomData)
    }
}
impl<CI> Default for SimpleAuthenticationProtocolClient<CI> {
    fn default() -> Self {
        Self::new()
    }
}
impl<CI> ClientProtocol<CI> for SimpleAuthenticationProtocolClient<CI> {
    fn id(&self) -> u16 {
        SIMPLE_AUTHENTICATION_PROTOCOL_ID
    }
    fn name(&self) -> String {
        "SimpleAuthenticationProtocol".to_string()
    }
    fn num_methods(&self) -> u32 {
        9u32
    }
    fn method_name(&self, method_id: u32) -> Option<String> {
        SimpleAuthenticationProtocolMethod::try_from(method_id)
            .ok()
            .map(|e| format!("{:?}", e))
    }
}
#[allow(unused_variables)]
impl<CI> SimpleAuthenticationProtocolClient<CI> {
    pub fn authenticate(
        &self,
        logger: &Logger,
        ctx: &Context,
        ci: &mut ClientInfo<CI>,
        request: AuthenticateRequest,
    ) -> Result<AuthenticateResponse, Error> {
        warn!(
            logger,
            "Method {}.{} not implemented",
            "SimpleAuthenticationProtocol",
            stringify!(authenticate)
        );
        self.send(
            logger,
            ctx,
            ci,
            SimpleAuthenticationProtocolMethod::Authenticate as u32,
            request.to_bytes(),
        );
        Err(quazal::rmc::Error::UnimplementedMethod)
    }
    pub fn login_with_token(
        &self,
        logger: &Logger,
        ctx: &Context,
        ci: &mut ClientInfo<CI>,
        request: LoginWithTokenRequest,
    ) -> Result<LoginWithTokenResponse, Error> {
        warn!(
            logger,
            "Method {}.{} not implemented",
            "SimpleAuthenticationProtocol",
            stringify!(login_with_token)
        );
        self.send(
            logger,
            ctx,
            ci,
            SimpleAuthenticationProtocolMethod::LoginWithToken as u32,
            request.to_bytes(),
        );
        Err(quazal::rmc::Error::UnimplementedMethod)
    }
    pub fn login_with_token_ex(
        &self,
        logger: &Logger,
        ctx: &Context,
        ci: &mut ClientInfo<CI>,
        request: LoginWithTokenExRequest,
    ) -> Result<LoginWithTokenExResponse, Error> {
        warn!(
            logger,
            "Method {}.{} not implemented",
            "SimpleAuthenticationProtocol",
            stringify!(login_with_token_ex)
        );
        self.send(
            logger,
            ctx,
            ci,
            SimpleAuthenticationProtocolMethod::LoginWithTokenEx as u32,
            request.to_bytes(),
        );
        Err(quazal::rmc::Error::UnimplementedMethod)
    }
    pub fn login(
        &self,
        logger: &Logger,
        ctx: &Context,
        ci: &mut ClientInfo<CI>,
        request: LoginRequest,
    ) -> Result<LoginResponse, Error> {
        warn!(
            logger,
            "Method {}.{} not implemented",
            "SimpleAuthenticationProtocol",
            stringify!(login)
        );
        self.send(
            logger,
            ctx,
            ci,
            SimpleAuthenticationProtocolMethod::Login as u32,
            request.to_bytes(),
        );
        Err(quazal::rmc::Error::UnimplementedMethod)
    }
    pub fn login_with_sub_account(
        &self,
        logger: &Logger,
        ctx: &Context,
        ci: &mut ClientInfo<CI>,
        request: LoginWithSubAccountRequest,
    ) -> Result<LoginWithSubAccountResponse, Error> {
        warn!(
            logger,
            "Method {}.{} not implemented",
            "SimpleAuthenticationProtocol",
            stringify!(login_with_sub_account)
        );
        self.send(
            logger,
            ctx,
            ci,
            SimpleAuthenticationProtocolMethod::LoginWithSubAccount as u32,
            request.to_bytes(),
        );
        Err(quazal::rmc::Error::UnimplementedMethod)
    }
    pub fn register(
        &self,
        logger: &Logger,
        ctx: &Context,
        ci: &mut ClientInfo<CI>,
        request: RegisterRequest,
    ) -> Result<RegisterResponse, Error> {
        warn!(
            logger,
            "Method {}.{} not implemented",
            "SimpleAuthenticationProtocol",
            stringify!(register)
        );
        self.send(
            logger,
            ctx,
            ci,
            SimpleAuthenticationProtocolMethod::Register as u32,
            request.to_bytes(),
        );
        Err(quazal::rmc::Error::UnimplementedMethod)
    }
    pub fn register_ex(
        &self,
        logger: &Logger,
        ctx: &Context,
        ci: &mut ClientInfo<CI>,
        request: RegisterExRequest,
    ) -> Result<RegisterExResponse, Error> {
        warn!(
            logger,
            "Method {}.{} not implemented",
            "SimpleAuthenticationProtocol",
            stringify!(register_ex)
        );
        self.send(
            logger,
            ctx,
            ci,
            SimpleAuthenticationProtocolMethod::RegisterEx as u32,
            request.to_bytes(),
        );
        Err(quazal::rmc::Error::UnimplementedMethod)
    }
    pub fn login_with_token_cafe(
        &self,
        logger: &Logger,
        ctx: &Context,
        ci: &mut ClientInfo<CI>,
        request: LoginWithTokenCafeRequest,
    ) -> Result<LoginWithTokenCafeResponse, Error> {
        warn!(
            logger,
            "Method {}.{} not implemented",
            "SimpleAuthenticationProtocol",
            stringify!(login_with_token_cafe)
        );
        self.send(
            logger,
            ctx,
            ci,
            SimpleAuthenticationProtocolMethod::LoginWithTokenCafe as u32,
            request.to_bytes(),
        );
        Err(quazal::rmc::Error::UnimplementedMethod)
    }
    pub fn login_with_token_cafe_ex(
        &self,
        logger: &Logger,
        ctx: &Context,
        ci: &mut ClientInfo<CI>,
        request: LoginWithTokenCafeExRequest,
    ) -> Result<LoginWithTokenCafeExResponse, Error> {
        warn!(
            logger,
            "Method {}.{} not implemented",
            "SimpleAuthenticationProtocol",
            stringify!(login_with_token_cafe_ex)
        );
        self.send(
            logger,
            ctx,
            ci,
            SimpleAuthenticationProtocolMethod::LoginWithTokenCafeEx as u32,
            request.to_bytes(),
        );
        Err(quazal::rmc::Error::UnimplementedMethod)
    }
}
