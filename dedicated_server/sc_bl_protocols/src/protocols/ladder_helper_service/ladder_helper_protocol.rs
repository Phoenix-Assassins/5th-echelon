// AUTOGENERATED with quazal-tools
#![allow(
    clippy::enum_variant_names,
    clippy::module_name_repetitions,
    clippy::too_many_lines,
    clippy::upper_case_acronyms,
    clippy::wildcard_imports
)]
use std::convert::TryFrom;

use num_enum::TryFromPrimitive;
use quazal::prudp::ClientRegistry;
use quazal::rmc::basic::FromStream;
use quazal::rmc::basic::ToStream;
use quazal::rmc::ClientProtocol;
use quazal::rmc::Error;
use quazal::rmc::Protocol;
use quazal::rmc::Request;
use quazal::ClientInfo;
use quazal::Context;
use slog::Logger;

#[allow(unused)]
use super::types::*;
pub const LADDER_HELPER_PROTOCOL_ID: u16 = 107u16;
#[derive(Debug, TryFromPrimitive)]
#[repr(u32)]
pub enum LadderHelperProtocolMethod {
    GetUnixUtc = 1u32,
    AreLaddersAvailableInCountry = 2u32,
    CheckLadderIsRunning = 3u32,
    ClearLadderLeaderboard = 4u32,
}
#[derive(Debug, ToStream, FromStream)]
pub struct GetUnixUtcRequest;
#[derive(Debug, ToStream, FromStream)]
pub struct GetUnixUtcResponse {
    pub time: u32,
}
#[derive(Debug, ToStream, FromStream)]
pub struct AreLaddersAvailableInCountryRequest;
#[derive(Debug, ToStream, FromStream)]
pub struct AreLaddersAvailableInCountryResponse {
    pub allowed: bool,
}
#[derive(Debug, ToStream, FromStream)]
pub struct CheckLadderIsRunningRequest {
    pub start_time: u32,
    pub end_time: u32,
}
#[derive(Debug, ToStream, FromStream)]
pub struct CheckLadderIsRunningResponse {
    pub running: bool,
}
#[derive(Debug, ToStream, FromStream)]
pub struct ClearLadderLeaderboardRequest {
    pub stat_set: i32,
}
#[derive(Debug, ToStream, FromStream)]
pub struct ClearLadderLeaderboardResponse {
    pub success: bool,
}
pub struct LadderHelperProtocolServer<T: LadderHelperProtocolServerTrait<CI>, CI>(T, ::std::marker::PhantomData<CI>);
impl<T: LadderHelperProtocolServerTrait<CI>, CI> LadderHelperProtocolServer<T, CI> {
    pub fn new(implementation: T) -> Self {
        Self(implementation, ::std::marker::PhantomData)
    }
}
impl<T: LadderHelperProtocolServerTrait<CI>, CI> Protocol<CI> for LadderHelperProtocolServer<T, CI> {
    fn id(&self) -> u16 {
        LADDER_HELPER_PROTOCOL_ID
    }
    fn name(&self) -> String {
        "LadderHelperProtocol".to_string()
    }
    fn num_methods(&self) -> u32 {
        4u32
    }
    fn handle(
        &self,
        logger: &Logger,
        ctx: &Context,
        ci: &mut ClientInfo<CI>,
        request: &Request,
        client_registry: &ClientRegistry<CI>,
        socket: &std::net::UdpSocket,
    ) -> Result<Vec<u8>, Error> {
        let method = LadderHelperProtocolMethod::try_from(request.method_id).ok();
        match method {
            None => Err(Error::UnknownMethod),
            Some(LadderHelperProtocolMethod::GetUnixUtc) => {
                let req = GetUnixUtcRequest::from_bytes(&request.parameters)?;
                debug!(logger, "Request: {:?}", req);
                let resp = self.0.get_unix_utc(logger, ctx, ci, req, client_registry, socket);
                debug!(logger, "Response: {:?}", resp);
                Ok(resp?.to_bytes())
            }
            Some(LadderHelperProtocolMethod::AreLaddersAvailableInCountry) => {
                let req = AreLaddersAvailableInCountryRequest::from_bytes(&request.parameters)?;
                debug!(logger, "Request: {:?}", req);
                let resp = self
                    .0
                    .are_ladders_available_in_country(logger, ctx, ci, req, client_registry, socket);
                debug!(logger, "Response: {:?}", resp);
                Ok(resp?.to_bytes())
            }
            Some(LadderHelperProtocolMethod::CheckLadderIsRunning) => {
                let req = CheckLadderIsRunningRequest::from_bytes(&request.parameters)?;
                debug!(logger, "Request: {:?}", req);
                let resp = self
                    .0
                    .check_ladder_is_running(logger, ctx, ci, req, client_registry, socket);
                debug!(logger, "Response: {:?}", resp);
                Ok(resp?.to_bytes())
            }
            Some(LadderHelperProtocolMethod::ClearLadderLeaderboard) => {
                let req = ClearLadderLeaderboardRequest::from_bytes(&request.parameters)?;
                debug!(logger, "Request: {:?}", req);
                let resp = self
                    .0
                    .clear_ladder_leaderboard(logger, ctx, ci, req, client_registry, socket);
                debug!(logger, "Response: {:?}", resp);
                Ok(resp?.to_bytes())
            }
        }
    }
    fn method_name(&self, method_id: u32) -> Option<String> {
        LadderHelperProtocolMethod::try_from(method_id)
            .ok()
            .map(|e| format!("{:?}", e))
    }
}
#[allow(unused_variables)]
pub trait LadderHelperProtocolServerTrait<CI> {
    fn get_unix_utc(
        &self,
        logger: &Logger,
        ctx: &Context,
        ci: &mut ClientInfo<CI>,
        request: GetUnixUtcRequest,
        client_registry: &ClientRegistry<CI>,
        _socket: &std::net::UdpSocket,
    ) -> Result<GetUnixUtcResponse, Error> {
        warn!(
            logger,
            "Method {}.{} not implemented",
            "LadderHelperProtocol",
            stringify!(get_unix_utc)
        );
        Err(quazal::rmc::Error::UnimplementedMethod)
    }
    fn are_ladders_available_in_country(
        &self,
        logger: &Logger,
        ctx: &Context,
        ci: &mut ClientInfo<CI>,
        request: AreLaddersAvailableInCountryRequest,
        client_registry: &ClientRegistry<CI>,
        _socket: &std::net::UdpSocket,
    ) -> Result<AreLaddersAvailableInCountryResponse, Error> {
        warn!(
            logger,
            "Method {}.{} not implemented",
            "LadderHelperProtocol",
            stringify!(are_ladders_available_in_country)
        );
        Err(quazal::rmc::Error::UnimplementedMethod)
    }
    fn check_ladder_is_running(
        &self,
        logger: &Logger,
        ctx: &Context,
        ci: &mut ClientInfo<CI>,
        request: CheckLadderIsRunningRequest,
        client_registry: &ClientRegistry<CI>,
        _socket: &std::net::UdpSocket,
    ) -> Result<CheckLadderIsRunningResponse, Error> {
        warn!(
            logger,
            "Method {}.{} not implemented",
            "LadderHelperProtocol",
            stringify!(check_ladder_is_running)
        );
        Err(quazal::rmc::Error::UnimplementedMethod)
    }
    fn clear_ladder_leaderboard(
        &self,
        logger: &Logger,
        ctx: &Context,
        ci: &mut ClientInfo<CI>,
        request: ClearLadderLeaderboardRequest,
        client_registry: &ClientRegistry<CI>,
        _socket: &std::net::UdpSocket,
    ) -> Result<ClearLadderLeaderboardResponse, Error> {
        warn!(
            logger,
            "Method {}.{} not implemented",
            "LadderHelperProtocol",
            stringify!(clear_ladder_leaderboard)
        );
        Err(quazal::rmc::Error::UnimplementedMethod)
    }
}
pub struct LadderHelperProtocolClient<CI>(::std::marker::PhantomData<CI>);
impl<CI> LadderHelperProtocolClient<CI> {
    pub fn new() -> Self {
        Self(::std::marker::PhantomData)
    }
}
impl<CI> Default for LadderHelperProtocolClient<CI> {
    fn default() -> Self {
        Self::new()
    }
}
impl<CI> ClientProtocol<CI> for LadderHelperProtocolClient<CI> {
    fn id(&self) -> u16 {
        LADDER_HELPER_PROTOCOL_ID
    }
    fn name(&self) -> String {
        "LadderHelperProtocol".to_string()
    }
    fn num_methods(&self) -> u32 {
        4u32
    }
    fn method_name(&self, method_id: u32) -> Option<String> {
        LadderHelperProtocolMethod::try_from(method_id)
            .ok()
            .map(|e| format!("{:?}", e))
    }
}
#[allow(unused_variables)]
impl<CI> LadderHelperProtocolClient<CI> {
    pub fn get_unix_utc(
        &self,
        logger: &Logger,
        ctx: &Context,
        ci: &mut ClientInfo<CI>,
        request: GetUnixUtcRequest,
    ) -> Result<GetUnixUtcResponse, Error> {
        warn!(
            logger,
            "Method {}.{} not implemented",
            "LadderHelperProtocol",
            stringify!(get_unix_utc)
        );
        self.send(
            logger,
            ctx,
            ci,
            LadderHelperProtocolMethod::GetUnixUtc as u32,
            request.to_bytes(),
        );
        Err(quazal::rmc::Error::UnimplementedMethod)
    }
    pub fn are_ladders_available_in_country(
        &self,
        logger: &Logger,
        ctx: &Context,
        ci: &mut ClientInfo<CI>,
        request: AreLaddersAvailableInCountryRequest,
    ) -> Result<AreLaddersAvailableInCountryResponse, Error> {
        warn!(
            logger,
            "Method {}.{} not implemented",
            "LadderHelperProtocol",
            stringify!(are_ladders_available_in_country)
        );
        self.send(
            logger,
            ctx,
            ci,
            LadderHelperProtocolMethod::AreLaddersAvailableInCountry as u32,
            request.to_bytes(),
        );
        Err(quazal::rmc::Error::UnimplementedMethod)
    }
    pub fn check_ladder_is_running(
        &self,
        logger: &Logger,
        ctx: &Context,
        ci: &mut ClientInfo<CI>,
        request: CheckLadderIsRunningRequest,
    ) -> Result<CheckLadderIsRunningResponse, Error> {
        warn!(
            logger,
            "Method {}.{} not implemented",
            "LadderHelperProtocol",
            stringify!(check_ladder_is_running)
        );
        self.send(
            logger,
            ctx,
            ci,
            LadderHelperProtocolMethod::CheckLadderIsRunning as u32,
            request.to_bytes(),
        );
        Err(quazal::rmc::Error::UnimplementedMethod)
    }
    pub fn clear_ladder_leaderboard(
        &self,
        logger: &Logger,
        ctx: &Context,
        ci: &mut ClientInfo<CI>,
        request: ClearLadderLeaderboardRequest,
    ) -> Result<ClearLadderLeaderboardResponse, Error> {
        warn!(
            logger,
            "Method {}.{} not implemented",
            "LadderHelperProtocol",
            stringify!(clear_ladder_leaderboard)
        );
        self.send(
            logger,
            ctx,
            ci,
            LadderHelperProtocolMethod::ClearLadderLeaderboard as u32,
            request.to_bytes(),
        );
        Err(quazal::rmc::Error::UnimplementedMethod)
    }
}
